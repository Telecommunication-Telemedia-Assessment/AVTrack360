"""
Contains functionality to convert an CSV playlist file (e.g. generated by Microsoft Excel or by this tool)
to a JSON playlist file which can be used by AVTrack360.

@author: Stephan Fremerey
"""

from argparse import ArgumentParser
from random import shuffle
import csv
import json
import sys

def convert_to_avtrack360_playlist(csvfile):
    row_number = 1
    with open('playlists\\' + csvfile) as csv_playlist:
        csv_reader = csv.reader(csv_playlist, delimiter=';')
        max_row = len(list(csv.reader(open('playlists\\' + csvfile))))
        for row in csv_reader:
            # Skip first row as it contains the description of the data
            if row_number == 1:
                pass
            # Write the content of the CSV file to a JSON file.
            else:
                # Set the label for the first row.
                if row_number == 2:
                    label = row[0]

                # If the next label starts, write the previous playlist data to a JSON file and clean the playlist data.
                if (row[0] != label):
                    with open('playlists\\' + label + '.json', mode='w') as new_file:
                        json.dump(playlist_data, new_file, indent=2,
                                  sort_keys=True, separators=(',', ':'))
                    label = row[0]
                    playlist_data = {'label': label, 'videos': []}

                # If no next label starts, just add the videos with metadata to the playlist data.
                label = row[0]
                filename = row[1]
                extension = row[2]
                projection_scheme = row[3]
                hmd = row[4]
                # Only for the first row: set the label in the written playlist data.
                if row_number == 2:
                    playlist_data = {'label': label, 'videos': []}

                playlist_data['videos'].append({'filename': "%s.%s" % (filename, extension),
                                                'projection_scheme': projection_scheme,
                                                'hmd': hmd})
                # If the last row is processed, write the playlist data to a JSON file.
                if row_number == max_row:
                    with open('playlists\\' + label + '.json', mode='w') as new_file:
                        json.dump(playlist_data, new_file, indent=2,
                                  sort_keys=True, separators=(',', ':'))

            row_number += 1

def main(_):
    parser = ArgumentParser(description="This is a small tool for converting a CSV playlist file "
                                        "generated by e.g. Microsoft Excel to JSON playlist files, "
                                        "which can be used by AVTrack360. If you want to use this tool for "
                                        "generating the randomized playlists, "
                                        "you have to set the parameters directly in the code.")
    parser.add_argument("-csvfile", dest="csvfile",
                        help="The path of the CSV file you want to convert. Default: dummy.csv", type=str)
    arg = parser.parse_args()
    hrcs = 8
    srcs = 8
    pvss = hrcs * srcs
    extension = "mkv"
    projection_scheme = "barrel360"
    hmd = "vive"
    subjects = 32
    csv = ["label;filename;extension;projectionscheme;hmd"]

    if arg.csvfile:
        convert_to_avtrack360_playlist(arg.csvfile)
    else:
        for subject in range(1, subjects + 1):
            csv_subject = []
            for src in range(1, srcs + 1):
                for hrc in range(1, hrcs + 1):
                    csv_subject.append("%s;SRC%s_HRC%03d;%s;%s;%s" % (subject, src, hrc, extension, projection_scheme, hmd))
            shuffle(csv_subject)
            for element in csv_subject:
                csv.append(element)
        with open('playlists\\generated_playlist.csv', mode='w') as csv_file:
            for element in csv:
                csv_file.write("%s\n" % element)
        convert_to_avtrack360_playlist("generated_playlist.csv")


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
